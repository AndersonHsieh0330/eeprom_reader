`timescale 1ns / 1ps

module top_level_sim_tb ();
logic SYS_CLK;
wire SDA;
logic SDA_q;
logic SCL;
logic read_en;
logic [3:0] LED;
logic [2:0] RBG_LED; // RGB => [2:0] respectively
logic [7:0] DATA_OUT;
// fpga I/O
logic reset;
logic start;
logic scl_reset;
  
assign SDA = ~read_en ? SDA_q : 1'bz;

// generated by crystal oscillator on board
always begin
   #0.5 SYS_CLK <= ~SYS_CLK;
end

initial begin
SYS_CLK <= 0;
reset <= 0;
start <= 0;
read_en <= 1;
scl_reset <= 0;
#1;
scl_reset <= 1;
#1;
scl_reset <= 0;
#1;
reset <= 1;
#2;
reset <= 0;
#2;
start <= 1;
#2;
start <= 0;
#1;

// ctrl byte + word address HIGH + LOW
for (int i = 0 ; i < 3 ; i = i + 1) begin
   #16;
   read_en <= 0;
   SDA_q <= 0;
   #2
   read_en <= 1;
end
#2; // start bit

// ctrl byte
#16;
read_en <= 0;
SDA_q <= 0;
#2

// data byte
read_en <= 0;
SDA_q <= 1;
for (int i = 0 ; i < 8 ; i = i + 1) begin
   SDA_q <= ~SDA_q;
   #2;
end

read_en <= 1;
#2; // no acknowledge
#2; // stop bit

#2; // buffer


end

top eeprom_interface_inst(
   .SYS_CLK(SYS_CLK), 
   .BTN({1'b0, scl_reset, start, reset}),     
   .SW(1'b1),      
   .SDA(SDA),
   .SCL_OUT(SCL),
   .LED(LED),     
   .LED0_R(RBG_LED[2]),  
   .LED0_G(RBG_LED[1]),
   .LED0_B(RBG_LED[0]),  
   .DATA_OUT(DATA_OUT)
);
endmodule
